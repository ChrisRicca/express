<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Express - Plugins</title>
    <link href='style.css' rel='stylesheet' />
  </head>
  <body>
    <a href='http://github.com/visionmedia/express'>
      <img alt='Fork me on GitHub' id='ribbon' src='http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png' />
    </a>
  </body>
  <div id='wrapper'>
    <div id='container'>
      <a href='http://github.com/visionmedia/express' id='logo'>Express</a>
      <ul id='menu'>
        <li>
          <a href='index.html'>Home</a>
          <a href='intro.html'>Intro</a>
          <a href='settings.html'>Settings</a>
          <a class='active' href='plugins.html'>Plugins</a>
        </li>
      </ul>
      <h2>Plugins</h2>
      <p>
        Express does not use "middleware" however
        <em>Plugins</em>
        take a similar form, allowing Express to
        respond to events, and extend core.
        <h2>Core Required Plugins</h2>
        <ul>
          <li>
            <a href='plugins.view.html'>View</a>
            - handles view rendering
          </li>
          <li>
            <a href='plugins.redirect.html'>Redirect</a>
            - provides redirection support
          </li>
          <li>
            <a href='plugins.body-decoder.html'>BodyDecoder</a>
            - automatically decodes common request bodies
          </li>
          <li>
            <a href='plugins.cache.html'>Cache</a>
            - provides unified caching api with default memory store
          </li>
        </ul>
        <h2>Core Optional Plugins</h2>
        <ul>
          <li>
            <a href='plugins.logger.html'>Logger</a>
            - provides several request logging formats
          </li>
          <li>
            <a href='plugins.content-length.html'>ContentLength</a>
            - automatically assigns the Content-Length response header
          </li>
          <li>
            <a href='plugins.method-override.html'>MethodOverride</a>
            - allows RESTful route support via faux HTTP method
          </li>
          <li>
            <a href='plugins.hooks.html'>Hooks</a>
            - provides before() and after() functions to act as request / response handlers
          </li>
          <li>
            <a href='plugins.cookie.html'>Cookie</a>
            - provides low-level HTTP cookie support
          </li>
          <li>
            <a href='plugins.session.html'>Session</a>
            - persistent session data with plug-able data store, with default memory store
          </li>
          <li>
            <a href='plugins.flash.html'>Flash</a>
            - provides persistent notification queue
          </li>
        </ul>
      </p>
      <h2>Using Plugins</h2>
      <p>
        To use a plugin simply pass it to the
        <em>use()</em>
        function, after which each request will
        instantiate a new instance of your plugin,
        allowing it to perform request-specific
        processing.
      </p>
      <p>
        For example using the core
        <em>Logger</em>
        plugin we can require and pass it to
        <em>use()</em>
        .
      </p>
      <pre><code>use(require('express/plugins/logger').Logger)</code></pre>
      <p>As you can see, this is a bit messy; we can globalize these plugins by using</p>
      <pre><code>require('express/plugins')</code></pre>
      <p>after which we can simply:</p>
      <pre><code>use(Logger)</code></pre>
      <p>
        The
        <em>use()</em>
        function may receive the same plugin several
        times, however the last will always take precedence.
        This is useful for example when core uses
        <em>Cache</em>
        and
        <em>View</em>
        by default, however in your configurations you
        may wish to pass options like so:
      </p>
      <pre><code>use(Cache, { with: options })</code></pre>
      <h2>Writting Plugins</h2>
      <h3>Synchronous Example</h3>
      <div class='sect'>
        <p>
          Below is a basic profiler plugin example.
          First we extend the
          <em>Plugin</em>
          "class", and provide a few event handlers,
          in which we track the duration of a request
          by using the
          <em>request</em>
          and
          <em>response</em>
          event handlers.
        </p>
        <pre><code>exports.Profiler = Plugin.extend({&#x000A;  on: {&#x000A;    request: <span class="keyword">function</span>(event) {&#x000A;      this.start = Number(new Date)  &#x000A;    },&#x000A;    &#x000A;    response: <span class="keyword">function</span>(event) {&#x000A;      sys.puts(Number(new Date) - this.start + <span class="string">' ms'</span>)&#x000A;    }&#x000A;  }&#x000A;})</code></pre>
      </div>
      <h3>Asynchronous Example</h3>
      <div class='sect'>
        <p>
          Below we have an async example of a plugin,
          where
          <em>someAsyncFunction()</em>
          performs an async task such as
          IO, HTTP requests, DB interactions, etc.
        </p>
        <p>
          To indicate to Express that this event handler
          will be async, we must return
          <em>true</em>
          explicitly, and accept a
          <em>callback</em>
          function which should be called
          when your process has completed.
        </p>
        <pre><code>exports.AsyncDependencyExample = Plugin.extend({&#x000A;  on: {&#x000A;    request: <span class="keyword">function</span>(event, callback) {&#x000A;      someAsyncFunction(<span class="keyword">function</span>(){&#x000A;        callback()&#x000A;      })&#x000A;      <span class="keyword">return</span> true  &#x000A;    }&#x000A;  }&#x000A;})</code></pre>
      </div>
    </div>
  </div>
</html>
